\begin{frame}{Aufgabe 1}
In der Vorlesung haben wir darüber gesprochen, dass die interne Datenstruktur von Queues und Stacks frei gewählt werden kann. Soo könnte beispielsweise
ein Array oder auch eine Linked List verwendet werden.
	\begin{itemize}
		\item Welche Vorteile ergeben sich aus dieser Austauschbarkeit der Datenstruktur?
		\item Ist die Verwendung eines simplen Arrays als Datenstruktur für eine Queue bzw. einen Stack sinnvoll?
		\begin{itemize}
			\item Welche Vor- und Nachteile der Array Struktur sollte man berücksichtigen?
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Aufgabe 2}
Entwerft und implementiert eine Klasse zum repräsentieren eines Stacks oder einer Queue. Die interne Datenstruktur kann von euch frei gewählt werden.

Die Klasse sollte mindestens die folgenden Methoden zur Verfügung stellen:
\begin{itemize}
	\item \texttt{isEmpty} - Gibt zurück, ob die Struktur leer ist
	\item \texttt{peek} - Gibt das vorderste (für Queues) bzw. letzte (für Stacks) zurück
	\item \texttt{clear} - Entfernt alle Elemente aus der Datenstruktur
	\item \texttt{size} - Gibt die Anzahl der Elemente zurück
	\item Sowie die entsprechenden Operationen zum hinzufügen bzw. entfernen
\end{itemize}
\end{frame}

\begin{frame}{Aufgabe 3}
In der Vorlesung haben wir über binäre Suchbäume gesprochen. 
	\begin{itemize}
		\item Zeichnet den entstehenden Baum, wenn ihr nacheinander die Elemente $(47. 63. 25. 13. 57. 18. 99. 14. 22. 37. 24. 28. 30.)$ hinzufügt.
		\item Wie sieht der resultierende Baum aus, wenn ihr das Element $13$ entfernt?
		\item Wie sieht der Baum aus, wenn ihr weiterhin das Element $25$ entfernt
	\end{itemize}
\end{frame}

\begin{frame}{Aufgabe 4}
Mithilfe von ausgeglichenen Bäumen kann die Suchzeit in Binärbäumen optimiert werden. Eine Möglichkeit zur Erstellung eines ausgeglichenen Baumes stellt die
AVL Bedingung dar. Durch diese wird sichergestellt, dass sich die Tiefen der Teilbäume zu jedem Zeitpunkt um maximal 1 unterscheiden.

\begin{itemize}
	\item Fügt in der gegebenen Reihenfolge die Elemente in einen intial leeren Binärbaum ein: $3.2.1.4.5.6.7.16.15$
\end{itemize}
\end{frame}