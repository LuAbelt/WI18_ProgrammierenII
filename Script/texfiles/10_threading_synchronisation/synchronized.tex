\begin{frame}{Synchronized}{The old way}
    \begin{itemize}
        \item Über das \texttt{synchronized} Schlüsselwort lässt sich die gleiche Funktionalität wie mit \textit{Locks} erreichen
        \item Sind seit Java 1.0 Teil der Sprache
        \item Können jedoch direkt in Methodensignaturen verwendet werden
        \item Dadurch wird sichergestellt, dass eine Methode eines Objekts nur gleichzeitig durch einen Thread aufgerufen wird
        \item Auf verschiedenen Objekten kann die Methode weiterhin gleichzeitig aufgerufen werden
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Synchronized}{In der Methodensignatur}
\lstset{style=java}
\begin{lstlisting}
synchronized void foo(){
  i++;
}
\end{lstlisting}
\end{frame}

\begin{frame}{Synchronized}{}
    \begin{itemize}
        \item \texttt{synchronized} kann beliebig atomare Codeausschnitte umfassen
        \item Im Block wird angegeben auf welches Objekt ein Monitor gesetzt wird
        \item Wie beim Aufruf von \texttt{lock} wird geprüft ob ein anderer Thread in einem synchronized Block mit dem gleichen Monitor ist
        \item Und es wird ggf. gewartet bis dieser abgeschlossen ist
        \item Über \texttt{Thread.holdsLock} lässt sich prüfen, ob der aktuelle Thread den Monitor für ein Objekt hält
    \end{itemize}
\end{frame}

\begin{frame}{Deadlocks}{}
    \begin{itemize}
        \item Die Abhängigkeiten von Monitoren müssen unbedingt berücksichtigt werden
        \item Insbesondere wenn mehrere Locks in verschiedene Methoden verwendet werden
        \item Sonst kann es im Programm zu einem sog. "`Deadlock"' kommen
        \begin{itemize}
            \item Zwei Programmabschnitte warten auf die Freigabe eines Monitors
            \item Der durch den jeweils anderen blockiert wird
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{Deadlocks}
    \includegraphics[height=5.5cm]{graph/deadlock}
\end{frame}