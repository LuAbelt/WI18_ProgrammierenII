\begin{frame}{Datentypen}{Unterscheidung}
	\begin{itemize}
		\item Primitive Datentypen
		\item Objektorientierte Datentypen
		\item Strukturierte Datentypen
	\end{itemize}
\end{frame}

\begin{frame}{Primitive Datentypen}{Beispiele}
	\begin{itemize}
	\item Beispiele:
		\begin{itemize}
			\item int
			\item boolean
			\item char
			\item float
			\item double
			\item long
			\item byte
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Primitive Datentypen}{Eigenschaften}
	\begin{itemize}
		\item Rein zum speichern von Daten
		\item Feste Speichergröße
		\item Feste Präzision $\Rightarrow$ Diskret
		\item Fest definierte Ober- und Untergrenze
		\item Implementieren selbst keine Algorithmen, sondern nur simple Operationen
		\item Menge an Operationen beschränkt (+,-,*,/ und ggf. Bitwise Operations)
		\begin{itemize}
			\item Und nicht erweiterbar (Vgl. Objektorientierte Datentypen)
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Primitive Datentypen}{Eigenschaften (In Java)}
	\begin{tabular}{|c|c|c|c|}
	\hline
	\textbf{Typ} & \textbf{Größe (Bits)} & \textbf{Minimum} & \textbf{Maximum}
	\\
	\hline
	\visible<+->{\textbf{byte}} & \visible<+->{8} & \visible<+->{$ -128 $} & \visible<+->{$ 127 $}\\
	\hline
	\textbf{char} & \visible<+->{16} & \visible<+->{$ 0 $} & \visible<+->{$ 2^{16}-1 $}\\
	\hline
	\textbf{short} & \visible<+->{16} & \visible<+->{$ -2^{15} $} & \visible<+->{$ 2^{15}-1 $}\\
	\hline
	\textbf{int} & \visible<+->{32} & \visible<+->{$ -2^{31} $} & \visible<+->{$ 2^{31}-1 $}\\
	\hline
	\textbf{long} & \visible<+->{64} & \visible<+->{$ -2^{63} $} & \visible<+->{$ 2^{63}-1 $}\\
	\hline
	\textbf{float} & \visible<+->{32} & \visible<+->{$ \pm 1.4\text{E-}45 $} & \visible<+->{$ \pm 3.4\text{E+}38 $}\\
	\hline
	\textbf{double} & \visible<+->{64} & \visible<+->{$ \pm 4.9\text{E-}324 $} & \visible<+->{$ \pm 1.7\text{E+}324 $}\\
	\hline
	\textbf{boolean} & \visible<+->{Undefiniert} & \multicolumn{2}{c|}{\visible<+->{Nur \tt{true} und \tt{false}}}\\
	\hline
	\end{tabular}
\end{frame}

\begin{frame}{Primitive Datetypen}{Umwandlung}
	\begin{alertblock}{Implizite Umwandlung}
		Für die meisten Fälle gilt: Primitive Datentypen lassen sich grundsätzlich implizit umwandeln, wenn die Präzision des Zieldatentyps höher ist als die des Ursprungsdatentyps. Also:
		
		\begin{center}
		\tt{byte} $\Rightarrow$ \tt{short} $\Rightarrow$ \tt{int} $\Rightarrow$ \tt{long} $\Rightarrow$ \tt{float} $\Rightarrow$ \tt{double}
		\end{center}
	\end{alertblock}
\end{frame}

\begin{frame}{Primitive Datentypen}{Umwandlung}
	\begin{alertblock}{Explizite Umwandlung}
		Alle anderen Umwandlungen müssen explizit durchgeführt werden zum Beispiel durch nutzen von Casting.
		
		\textbf{Achtung:} Dies kann zu Datenverlust führen. Beispiel: Umwandlung von \tt{float} in \tt{int} $\Rightarrow$ Dezimalstellen gehen verloren.
	\end{alertblock}
\end{frame}

\begin{frame}{Objektorientierte Datentypen}{Grundlegendes}
	\begin{itemize}
		\item Zusammenfassen von Daten und Algorithmen in eine gemeinsame Instanz $\Rightarrow$ \textbf{Klasse}
		\item Von einer Klasse können mehrere unabhängige Instanzen existieren $\Rightarrow$ \textbf{Objekt}
		\item Entwickler entscheidet wie mit der Klasse interagiert werden muss $\Rightarrow$ \textbf{Datenkapselung}
		\item Klassen lassen sich wiederverwenden $\Rightarrow$ Verringerter Arbeitsaufwand durch gut designete Klassen
		\begin{itemize}
			\item Durch Verwendung weiterführender Konzepte (wie z.B. Design Patterns) noch gestärkt
		\end{itemize}
		\item Bilden die Grundlage von Java
	\end{itemize}
\end{frame}

\begin{frame}{Objektorientierte Datentypen}{Vererbung}
	\begin{itemize}
		\item Grundpfeiler der Objektorientierung
		\item Unterklassen \textbf{müssen} die Schnittstellen der Superklasse übernehmen
		\begin{itemize}
			\item Können neue Methoden und Variablen hinzufügen
			\item Können vorhandene Methoden überschreiben $\Rightarrow$ Implementieren spezifischer Logik
			\item Variablen bzw. Methoden können durch Vererbung \textbf{NICHT} entfernt werden
		\end{itemize}
		\item Objekte der Unterklassen können anstelle der Oberklasse treten
		\begin{itemize}
			\item Frage: Warum nicht umgekehrt?
		\end{itemize}
	\end{itemize}
\end{frame}

%TODO: Hier evtl. Codebeispiel Vererbung?

\begin{frame}{Objektorientierte Datentypen}{Vererbung}
	\begin{itemize}
		\item Formales OOP erlaubt Mehrfachvererbung, nutzbar in z.B.:
		\begin{itemize}
			\item C++
			\item Python
			\item Perl
		\end{itemize}
		\item In Java: Nur Einfachvererbung erlaubt
		\begin{itemize}
			\item Weitere Sprachen mit Einfachvererbung:
			\item C\#
			\item Ruby
		\end{itemize}
		\item Einige Funktionalitäten lassen sich über Interfaces abbilden
	\end{itemize}
\end{frame}

\begin{frame}{Objektorientierte Datentypen}{Interfaces}
	\begin{minipage}{0.4\textwidth}
			\begin{figure}
				\includegraphics[height=3.35cm]{graph/judt}
				\caption*{Quelle: \url{https://www.researchgate.net/profile/Andreas_Judt}}
				\label{fig:ll}
			\end{figure}
		\end{minipage}
		\hfill
		\begin{minipage}{0.55\textwidth}
			\textit{„Java hat das Konzept der Mehrfachvererbung über die Nutzung von Interfaces durch die Hintertür eingeführt.“} \\\\Andreas Judt
		\end{minipage}
\end{frame}

\begin{frame}{Objektorientierte Datentypen}{Interfaces}
	\item Definieren einen Satz an Methoden
	\item Implementierung der Funktionen erfolgt auf Klassenebene
	\begin{itemize}
		\item Seit Java 8: Definition von Standardimplementierung im Interface möglich
	\end{itemize}
	\item Klassen implementieren beliebig viele Interfaces
	\item Java bietet viele Standardinterfaces wie z.B.:
	\begin{itemize}
		\item Comparable
		\item Iterable
		\item Serializable
	\end{itemize}
\end{frame}

\begin{frame}{Strukturierte Datentypen}{Allgemeines}
	
\end{frame}

% Strukturierte Datentypen
% Enum
% Structs
% Union
