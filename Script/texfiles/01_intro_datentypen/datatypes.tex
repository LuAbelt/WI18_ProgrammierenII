\begin{frame}{Datentypen}{Unterscheidung}
	\begin{itemize}
		\item Primitive Datentypen
		\item Objektorientierte Datentypen
		\item Strukturierte Datentypen
	\end{itemize}
\end{frame}

\begin{frame}{Primitive Datentypen}{Beispiele}
	\begin{itemize}
	\item Beispiele:
		\begin{itemize}
			\item int
			\item boolean
			\item char
			\item float
			\item double
			\item long
			\item byte
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Primitive Datentypen}{Eigenschaften}
	\begin{itemize}
		\item Rein zum speichern von Daten
		\item Feste Speichergröße
		\item Feste Präzision $\Rightarrow$ Diskret
		\item Fest definierte Ober- und Untergrenze
		\item Implementieren selbst keine Algorithmen, sondern nur simple Operationen
		\item Menge an Operationen beschränkt (+,-,*,/ und ggf. Bitwise Operations)
		\begin{itemize}
			\item Und nicht erweiterbar (Vgl. Objektorientierte Datentypen)
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Primitive Datentypen}{Eigenschaften (In Java)}
	\begin{tabular}{|c|c|c|c|}
	\hline
	\textbf{Typ} & \textbf{Größe (Bits)} & \textbf{Minimum} & \textbf{Maximum}
	\\
	\hline
	\visible<+->{\textbf{byte}} & \visible<+->{8} & \visible<+->{$ -128 $} & \visible<+->{$ 127 $}\\
	\hline
	\textbf{char} & \visible<+->{16} & \visible<+->{$ 0 $} & \visible<+->{$ 2^{16}-1 $}\\
	\hline
	\textbf{short} & \visible<+->{16} & \visible<+->{$ -2^{15} $} & \visible<+->{$ 2^{15}-1 $}\\
	\hline
	\textbf{int} & \visible<+->{32} & \visible<+->{$ -2^{31} $} & \visible<+->{$ 2^{31}-1 $}\\
	\hline
	\textbf{long} & \visible<+->{64} & \visible<+->{$ -2^{63} $} & \visible<+->{$ 2^{63}-1 $}\\
	\hline
	\textbf{float} & \visible<+->{32} & \visible<+->{$ \pm 1.4\text{E-}45 $} & \visible<+->{$ \pm 3.4\text{E+}38 $}\\
	\hline
	\textbf{double} & \visible<+->{64} & \visible<+->{$ \pm 4.9\text{E-}324 $} & \visible<+->{$ \pm 1.7\text{E+}324 $}\\
	\hline
	\textbf{boolean} & \visible<+->{Undefiniert} & \multicolumn{2}{c|}{\visible<+->{Nur \tt{true} und \tt{false}}}\\
	\hline
	\end{tabular}
\end{frame}

\begin{frame}{Primitive Datetypen}{Umwandlung}
	\begin{alertblock}{Implizite Umwandlung}
		Für die meisten Fälle gilt: Primitive Datentypen lassen sich grundsätzlich implizit umwandeln, wenn die Präzision des Zieldatentyps höher ist als die des Ursprungsdatentyps. Also:
		
		\begin{center}
		\tt{byte} $\Rightarrow$ \tt{short} $\Rightarrow$ \tt{int} $\Rightarrow$ \tt{long} $\Rightarrow$ \tt{float} $\Rightarrow$ \tt{double}
		\end{center}
	\end{alertblock}
\end{frame}

\begin{frame}{Primitive Datentypen}{Umwandlung}
	\begin{alertblock}{Explizite Umwandlung}
		Alle anderen Umwandlungen müssen explizit durchgeführt werden zum Beispiel durch nutzen von Casting.
		
		\textbf{Achtung:} Dies kann zu Datenverlust führen. Beispiel: Umwandlung von \tt{float} in \tt{int} $\Rightarrow$ Dezimalstellen gehen verloren.
	\end{alertblock}
\end{frame}

\begin{frame}{Objektorientierte Datentypen}{Grundlegendes}
	\begin{itemize}
		\item Zusammenfassen von Daten und Algorithmen in eine gemeinsame Instanz $\Rightarrow$ \textbf{Klasse}
		\item Von einer Klasse können mehrere unabhängige Instanzen existieren $\Rightarrow$ \textbf{Objekt}
		\item Entwickler entscheidet wie mit der Klasse interagiert werden muss $\Rightarrow$ \textbf{Datenkapselung}
		\item Klassen lassen sich wiederverwenden $\Rightarrow$ Verringerter Arbeitsaufwand durch gut designete Klassen
		\begin{itemize}
			\item Durch Verwendung weiterführender Konzepte (wie z.B. Design Patterns) noch gestärkt
		\end{itemize}
		\item Bilden die Grundlage von Java
	\end{itemize}
\end{frame}

\begin{frame}{Objektorientierte Datentypen}{Vererbung}
	\begin{itemize}
		\item Grundpfeiler der Objektorientierung
		\item Unterklassen \textbf{müssen} die Schnittstellen der Superklasse übernehmen
		\begin{itemize}
			\item Können neue Methoden und Variablen hinzufügen
			\item Können vorhandene Methoden überschreiben $\Rightarrow$ Implementieren spezifischer Logik
			\item Variablen bzw. Methoden können durch Vererbung \textbf{NICHT} entfernt werden
		\end{itemize}
		\item Objekte der Unterklassen können anstelle der Oberklasse treten
		\begin{itemize}
			\item Frage: Warum nicht umgekehrt?
		\end{itemize}
	\end{itemize}
\end{frame}

%TODO: Hier evtl. Codebeispiel Vererbung?

\begin{frame}{Objektorientierte Datentypen}{Vererbung}
	\begin{itemize}
		\item Formales OOP erlaubt Mehrfachvererbung, nutzbar in z.B.:
		\begin{itemize}
			\item C++
			\item Python
			\item Perl
		\end{itemize}
		\item In Java: Nur Einfachvererbung erlaubt
		\begin{itemize}
			\item Weitere Sprachen mit Einfachvererbung:
			\item C\#
			\item Ruby
		\end{itemize}
		\item Einige Funktionalitäten lassen sich über Interfaces abbilden
	\end{itemize}
\end{frame}

\begin{frame}{Objektorientierte Datentypen}{Interfaces}
	\begin{minipage}{0.4\textwidth}
			\begin{figure}
				\includegraphics[height=3.35cm]{graph/judt}
				\caption*{Quelle: \url{https://www.researchgate.net/profile/Andreas_Judt}}
				\label{fig:ll}
			\end{figure}
		\end{minipage}
		\hfill
		\begin{minipage}{0.55\textwidth}
			\textit{„Java hat das Konzept der Mehrfachvererbung über die Nutzung von Interfaces durch die Hintertür eingeführt.“} \\\\Andreas Judt
		\end{minipage}
\end{frame}

\begin{frame}{Objektorientierte Datentypen}{Interfaces}
	\begin{itemize}
		\item Definieren einen Satz an Methoden
		\item Implementierung der Funktionen erfolgt auf Klassenebene
		\begin{itemize}
			\item Seit Java 8: Definition von Standardimplementierung im Interface möglich
		\end{itemize}
		\item Klassen implementieren beliebig viele Interfaces
		\item Java bietet viele Standardinterfaces wie z.B.:
		\begin{itemize}
			\item Comparable
			\item Iterable
			\item Serializable
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Strukturierte Datentypen}{Allgemeines}
	\begin{itemize}
		\item Sind irgendwo zwischen Primitiven und Objektorientierten Datentypen einzuordnen
		\item In Java jedoch als Klassen umgesetzt (Sofern vorhanden)
		\item Wir betrachten folgende:
		\begin{itemize}
			\item Enumerations
			\item Structs
			\item Union
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Strukturierte Datentypen}{Enumerations}
	\begin{itemize}
		\item Ist eine Menge von geordneten, benannten Werten
		\item Werte der Enumeration können über Namen geprüft werden
		\item Anwendung:
		\begin{itemize}
			\item Beschränken einer Variable auf bestimmte definierte Werte
			\item Vermeiden von „Magic Numbers“ $\Rightarrow$ Code-Lesbarkeit
		\end{itemize}
		\item In den meisten Sprachen sind Enum Werte im Hintergrund nur Integer Konstanten
		\item In Java: Automatisch Klasse
		\begin{itemize}
			\item Dadurch höhere Flexibilität
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Enumerations}{Beispiel I}
Enumeration zur Repräsentation der Wochentage sieht zum Beispiel so aus:
\lstset{style=javacode}
\begin{lstlisting}
enum Weekday {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
}
//Spaetere Nutzung im Code:
Weekday myDay = Weekday.TUESDAY;
\end{lstlisting}
\end{frame}

\begin{frame}{Enumerations}{Beispiel II}
Java Enumeration-Klassen erlauben nun aber auch komplexere Konstrukte. Beispiel anhand der Planeten unseres Sonnensystems:
%TODO: Code Beispiel Planeten (Siehe Javadocs)
\end{frame}

\begin{frame}{Strukturierte Datentypen}{Structs}
	\begin{itemize}
		\item Fassen mehrere Einzelvariablen zu einer Struktur zusammen
		\item Reine Datenstruktur zum erfassen von Daten
		\begin{itemize}
			\item Keine Methoden
			\item Keine Zugriffsspezifizierer
		\end{itemize}
		\item In Java kein separates Konzept $\Rightarrow$ Sonderfall einer Klasse
	\end{itemize}
\end{frame}
%TODO: Codebeispiele Vergleich Struct C++/Java

\begin{frame}{Strukturierte Datentypen}{Unions}
	\begin{itemize}
		\item Enthält mehrere Variablen
		\item Diese teilen sich den gleichen Speicher
		\item Variablen können demnach nicht unabhängig voneinander verändert werden
		\item Kein (mir bekanntes) äquivalent in Java
	\end{itemize}
\end{frame}
