\outlineSubframe{Formale Eigenschaften}

\begin{frame}{Eigenschaften von Algorithmen}{Grundlegendes}
    \begin{itemize}[<+->]
        \item \textbf{Finitheit} - Ein Algorithmus lässt sich in endlch vielen Schritten eindeutig beschreiben
        \item \textbf{Ausführbarkeit} - Jeder Einzelschritt muss tatsächlich ausführbar sein
        \item \textbf{Platzkomplexität} - Ein Algorithmus benötigt zu jedem Zeitpunkt nur endlich viel Speicherplatz
        \item \textbf{Terminierung} - Der Algorithmus benötigt eine endliche Anzahl von Schritten zur Ausführung
        \item \textbf{Determiniertheit} - Der Algorithmus muss bei gleichen Rahmenbedingungen das gleiche Ergebnis liefern
        \item \textbf{Determinismus} - Der nächste Schritt des Algorithmus ist zu jedem Zeitpunkt genau definiert
    \end{itemize}
\end{frame}

\begin{frame}{Korrektheit von Algorithmen}{}
    \begin{itemize}[<+->]
        \item Jeder Algorithmus sollte auch in allen Fällen das korrekte Ergebnis liefern...
        \item Klingt simpel, aber eindeutiger Beweis für alle Eingaben oft schwierig
        \item Testen an ausgewählten Beispielen \textbf{nicht} ausreichend
        \begin{itemize}
            \item Jedoch verringern umfangreiche Tests natürlich das Risiko eines unentdeckten Fehler
        \end{itemize}
        \item Korrektheit lässt sich im Grunde nur durch formalen Beweis zeigen
        \begin{itemize}
            \item Diese sind häufig sehr umfangreich und komplex...
            \item ...und deshalb auch nicht Teil der Vorlesung
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{Korrektheit von Algorithmen}{}
\begin{minipage}{0.4\textwidth}
            \begin{figure}
                \includegraphics[height=4.5cm]{graph/dijkstra}
                \caption*{Quelle: }%\url{https://upload.wikimedia.org/wikipedia/commons/d/d9/Edsger_Wybe_Dijkstra.jpg}}
            \end{figure}
        \end{minipage}
        \hfill
        \begin{minipage}{0.55\textwidth}
            \textit{„Program testing can be used to show the presence of bugs, but never to show their absence!.“} \\\\Edsger W. Dijkstra
        \end{minipage}
\end{frame}

\begin{frame}{Effizienz von Algorithmen}{}
    \begin{itemize}
        \item Ergibt sich indirekt aus den Grundlegenden Eigenschaften
        \item Effizienz lässt sich über verschiedene Größen beschreiben:
        \begin{itemize}
            \item Speicherverbrauch
            \item Zeitverbrauch
        \end{itemize}
        \item Die sind jedoch oft Implementierungs- und Rechnerabhägig
        \item Deshalb wird mit formalisierten Modellen gearbeitet
        \item ...Mehr dazu im Kapitel "`Analyse"'
    \end{itemize}
\end{frame}

\outlineSubframe{Darstellungsformen}

\begin{frame}{Möglichkeiten der Darstellung}{}
    \begin{itemize}[<+->]
        \item Zur Definition von Algorithmen gibt es verschiedenste Möglichkeiten
        \item Mit ganz eigenen Vor- und Nachteilen
        \item Wir betrachten im Rahmen der Vorlesung:
        \begin{itemize}
            \item Prosatext
            \item Pseudocode
            \item Struktogramme
            \item Programmablaufplan (PAP)
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{Was beschreiben wir?}{Unser Referenzalgorithmus}
    \begin{itemize}
        \item Um die verschiedenen Elemente zu vergleichen, wollen wir mit allen den folgenden Algorithmus beschreiben:
    \end{itemize}
    \pause
    \begin{alertblock}{Referenz}
        Für eine Zahl $n$ (Wobei gilt: $n \in \mathbb{N} $), soll die Summe aller geraden Zahlen von $0$ bis $n$ berechnet werden.
    \end{alertblock}
\end{frame}

\begin{frame}{Darstellung als Prosatext}{Der simple Weg}
    \begin{itemize}
        \item Simpelste Herangehensweise
        \item Man beschreibt in eigenen Worten, wie man vorgehen würde um die gegebene Problemstellung zu lösen
        \item \textbf{Achtung:} Unterscheiden zwischen Problemstellung und Lösungsbeschreibung!
        \item Auch in Prosaform sollten die Einzelschritte eindeutig beschrieben sein
        \item Nicht standardisiert $\rightarrow$ Beschreibung von Algorithmen inkonsistent
    \end{itemize}
\end{frame}

\begin{frame}{Prosabeschreibung}{Für unseren Algorithmus}
    \begin{alertblock}{Addiere alle geraden Zahlen}
    \visible<2->{Lese die Zahl \texttt{n} ein.}
    
    \visible<3->{Anschließend setze die Zählvariable \texttt{i} sowie die Ergebnisvariable \texttt{res} auf \texttt{0}.}
    
    \visible<4->{Wenn \texttt{i} gerade ist, addiere \texttt{i} auf die Ergebnisvariable.} \visible<5->{Erhöhe anschließend \texttt{i} um \texttt{1}.} \visible<6->{Wiederhole die letzten zwei Schritte bis \texttt{i} größer ist als \texttt{n}.}
    
    \visible<7->{Gebe \texttt{res} aus}
    \end{alertblock}
\end{frame}

\begin{frame}{Darstellung als Pseudocode}{Der Zwischenweg}
    \begin{itemize}
        \item Mischung aus Prosa und tatsächlichem Code
        \item Orientiert sich an den in Programmiersprachen vorhandenen Strukturen (If-then-else, Schleifen...)
        \item Nutzt dabei aber leicht verständliche und programmiersprachenunabhängige Begriffe
        \item Wie Code in der Regel zeilenweise auf atomare Operationen beschränkt
        \item Keine formale Standardisierung, dadurch auch hier Inkonsistenzen möglich $\rightarrow$ Aber weniger als bei Prosabeschreibung
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Pseudocode}{Für unser Pseudoproblem}
\lstset{style=pseudo}
\begin{lstlisting}
LESE n
SETZE res=0
FUER i=0 BIS n
    WENN istGerade(i) DANN
        res+=i
    ENDE WENN
ENDE FUER
GEBE res AUS
\end{lstlisting}
\end{frame}

\begin{frame}{Struktogramme}{Der erste Standard}
    \begin{itemize}
        \item Entwickelt durch \textit{Nassi Shneidermann}
        \item Grafische Darstellung von Algorithmen
        \item Standardisiert nach \textbf{DIN 66261}
        \item Zerlegt den Algorithmus in elementare Grundstrukturen
        \item Die über die definierten Blöcke dargestellt werden
        \item Werden (lückenlos) von oben nach unten aneinander gereiht
    \end{itemize}
\end{frame}

\begin{frame}{Elemente von Struktogrammen}{Anweisung}
TODO: Abbildung Anweisungsblock
\end{frame}

\begin{frame}{Elemente von Struktogrammen}{Verzweigungen}
TODO: Abbildung Verzweigungen
\end{frame}

\begin{frame}{Elemente von Struktogrammen}{Zählschleifen}
TODO: Abbildung Zählschleife
\end{frame}

\begin{frame}{Elemente von Struktogrammen}{Schleifen}
TODO: Abbildung Schleifen
\end{frame}

\begin{frame}{Struktogram für unseren Algorithmus}
TODO: Struktogram Algorithmus
\end{frame}

\begin{frame}{Programmablaufplan}{Der zweite Standard}
    \begin{itemize}
        \item Bildet einen linearen Programmfluss aber
        \item Standardisiert nach \textbf{DIN 66001}
        \item Wie beim Struktogramm gibt es fest definierte Grundblöcke
        \item Diese werden hier jedoch über Pfeile verbunden
    \end{itemize}
\end{frame}

\begin{frame}{Elemente von Programmablaufplänen}{Start, Stop, Anweisungsblock, Ein- und Ausgaben}
TODO: Abbildung Anweisungsblock
\end{frame}

\begin{frame}{Elemente von Programmablaufplänen}{Verzweigungen}
TODO: Abbildung Verzweigungen
\end{frame}

\begin{frame}{Elemente von Programmablaufplänen}{Zählschleifen}
TODO: Abbildung Zählschleife
\end{frame}

\begin{frame}{Elemente von Programmablaufplänen}{Schleifen}
TODO: Abbildung Schleifen
\end{frame}

\begin{frame}{Programmablaufplan für unseren Algorithmus}
TODO: PAP Algorithmus
\end{frame}